<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Dockerfile 学习</title>
      <link href="/2018/12/02/dockerfile/"/>
      <url>/2018/12/02/dockerfile/</url>
      <content type="html"><![CDATA[<h1 id="镜像构建"><a href="#镜像构建" class="headerlink" title="镜像构建"></a>镜像构建</h1><h2 id="构建前需要"><a href="#构建前需要" class="headerlink" title="构建前需要"></a>构建前需要</h2><ul><li>Dockerfile文件</li><li>构建所需的上下文（context）：可以是本地路径或者 Git仓库 URL</li></ul><h2 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h2><p>一般开发使用下面命令即可，更多参数可参考官方文档或docker build –help查看</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t &#123;name:tag&#125; .</span><br></pre></td></tr></table></figure><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol><li>把当前目录及子目录（递归，如果是 Git 仓库会会包含submodules）当做上下文传递给 Docker daemon。注意不是在 Docker Client 构建镜像。可以使用 .dockerignore 忽略掉一些构建不需要的文件。</li><li>默认从上下文的当前目录(不包括子目录)中找 Dockerfile 文件。当然也可以使用 -f 指定 Dockerfile 的路径，文件名也可以不叫 Dockerfile。</li><li>检查 Dockerfile 的语法</li><li>依次执行 Dockerfile 中的指令，根据指令生成中间过度镜像(存储在本地，为之后的指令或构建作缓存)</li></ol><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>构建命令后面的 . 不是 Dockerfile 的路径，而是上下文的路径。当然如果不显示指定 Dockerfile 的路径，默认 Dockerfile 也应该在该路径下。</li><li>-f 可以指定 Dockerfile 的路径，但是 Docker 18.03 之前的版本指定的 Dockerfile 需要在上下文目录或子目录下，在 Docker 18.03 之后可以指定 Dockerfile 路径在上下文目录外。（<a href="https://github.com/docker/cli/pull/886）">https://github.com/docker/cli/pull/886）</a></li><li>缓存：从缓存中存在的基础镜像开始，比较所有子镜像，检查它们构建的指令是否和当前的完全一致。如果不一致则缓存不匹配，重新构建镜像。Dockerfile 中每一个指令都会创建一个镜像层，上层是依赖于下层的。无论什么时候，只要某一层发生变化，其上面所有层的缓存都会失效。也就是说，如果我们改变 Dockerfile 指令的执行顺序，都会使缓存失效。所以书写 Dockerfile 时，应该将静态的安装、配置命令尽可能地放在 Dockerfile 的较前位置。</li><li>ADD 和 COPY 除了比较指令是否相同以外，Docker还会检查每个文件内容校验和是否一致。</li><li>除了ADD和COPY之外，Docker 缓存检查并不会检查文件内容是否匹配，如 RUN yum update -y 可能会一直使用缓存镜像，不会更新使用最新的软件版本。如果希望不使用缓存，可以使用参数–no-cache 重新生成镜像。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Maven 学习</title>
      <link href="/2018/12/01/maven/"/>
      <url>/2018/12/01/maven/</url>
      <content type="html"><![CDATA[<h1 id="Maven-使用注意事项"><a href="#Maven-使用注意事项" class="headerlink" title="Maven 使用注意事项"></a>Maven 使用注意事项</h1><h3 id="元素：updatePolicy"><a href="#元素：updatePolicy" class="headerlink" title="元素：updatePolicy"></a>元素：updatePolicy</h3><p>Maven 从远程仓库检查更新频率，默认值为：daily。</p><p>对于依赖 snapshots 的包要注意，有时取到的依赖包不是最新的就是这个原因。</p><p>可在 mvn 命令行中使用参数 -U 强制更新，使用参数后构建会忽略updatePolicy的配置。</p><h3 id="元素：checksumPolicy"><a href="#元素：checksumPolicy" class="headerlink" title="元素：checksumPolicy"></a>元素：checksumPolicy</h3><p>Maven检查检验和文件的策略，默认值是：warn。下载包时校验和验证失败，只是输出警告信息，并不会中断下载。还有 failed 和 ignore 选项。</p><h3 id="镜像-settings-xml配置"><a href="#镜像-settings-xml配置" class="headerlink" title="镜像(settings.xml配置)"></a>镜像(settings.xml配置)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">  &lt;mirror&gt;</span><br><span class="line">   &lt;id&gt;aliyun-mirror&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun mirror&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">  &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure><p>mirrorOf 里是要替代的仓库的 id。 也就是说 Maven 对该 id 仓库的请求会被拦截，改变为指向该镜像的仓库。</p><p>配置为 central，表示为 Maven 中央仓库(<a href="https://repo.maven.apache.org/maven2/">https://repo.maven.apache.org/maven2/</a>) 的镜像，对于中央仓库的请求都会被拦截指向该镜像。由于镜像仓库会完全屏蔽被镜像仓库，所以当镜像仓库无法提供服务时，Maven 仍然无法访问被镜像仓库，无法下载仓库文件。</p><p><strong>注意:</strong> 如果配置为 <code>&lt;mirrorOf&gt; * &lt;/mirrorOf&gt;</code>则意味着拦截所有的远程仓库，所有 pom.xml 配置的远程仓库都会无效，谨慎使用。</p>]]></content>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python学习 - bool</title>
      <link href="/2018/07/19/python-bool/"/>
      <url>/2018/07/19/python-bool/</url>
      <content type="html"><![CDATA[<h2 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h2><p>只有两个值：True和False。 bool类型是integer类型的子类型，True和False可以分别当成1和0</p><ul><li>在Python2.7中，True和False是内建（built-in）变量，和普通自定义的变量一样可以被重新赋值。</li><li>在Python3.x中，True与False都是关键字。 关键字，意味着不能被赋值和篡改。(可使用 import keyword; print(keyword.kwlist) 查看所有关键字。)</li></ul><h2 id="bool-的-True-和-False"><a href="#bool-的-True-和-False" class="headerlink" title="bool 的 True 和 False"></a>bool 的 True 和 False</h2><p>下面的bool值为False，除此之外其他值均是True。</p><ul><li>None</li><li>False</li><li>数值类型的零值。 例如：0, 0.0, 0j,Decimal(0), Fraction(0, 1)</li><li>空的sequence和collections。例如： ‘’, (), [], {}, set(), range(0)</li><li>用户自定义类的实例， 如果类定义了 <code>__bool__</code> (Python2.7 为<code>__nonzero__()</code>）或者 <code>__len__()</code> 方法, 且方法返回的是整数零值或者布尔False。</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>上面最后一个要特别注意，被坑过。类的实例的bool值也可能是False，例如标准库中 xml.etree.ElementTree 类的实例的bool值就可能是False。</p><p>bool的判断逻辑顺序：</p><ul><li>只要一个类定义了 <code>__bool__()</code> 这个方法，那么它的实例的bool值，就是这个方法的返回值</li><li>如果一个类没有定义 <code>__bool__()</code>， 那么就会根据 <code>__len__()</code>方法的返回值判断，返回值是0就是False</li><li>如果 <code>__bool__()</code> 和 <code>__len__()</code> 方法都没有定义，则类的实例返回True</li></ul><h3 id="官方文档参考"><a href="#官方文档参考" class="headerlink" title="官方文档参考"></a><a href="https://docs.python.org/3/reference/datamodel.html#object.__bool__">官方文档参考</a></h3><ul><li><p>object.<code>__bool__</code>(self):  ( Python2.7 为 object.<code>__nonzero__</code>(self))</p><p>Called to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined, <code>__len__()</code> is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither <code>__len__()</code> nor <code>__bool__()</code>, all its instances are considered true.</p></li><li><p>object.<code>__len__</code>(self)：</p><p>Called to implement the built-in function len(). Should return the length of the object, an integer &gt;= 0. Also, an object that doesn’t define a <code>__bool__()</code> method and whose <code>__len__()</code> method returns zero is considered to be false in a Boolean context.</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DevOps 之路</title>
      <link href="/2018/06/18/DevOps/"/>
      <url>/2018/06/18/DevOps/</url>
      <content type="html"><![CDATA[<h2 id="Devops-实施的前提条件："><a href="#Devops-实施的前提条件：" class="headerlink" title="Devops 实施的前提条件："></a>Devops 实施的前提条件：</h2><p>软件架构解耦， 可独立部署，独立升级。</p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><ul><li><p>没有高效的流水线，何谈DevOps?</p><p>流水线是指软件从版本控制仓库到用户手中可使用这一过程的自动化表现形式。对软件的每次变更都会经历一系列的流程才能发布，这一流程包括单元测试、构建、打包、部署，集成测试， 性能测试，安全扫描，发布等。流水线是对这一流程的建模。</p></li><li><p>流水线的核心理念</p><p>基于价值的交付。基于数据的准确度量，帮助开发或者管理者评估产品价值和优化团队效率。</p></li></ul><h2 id="研发模式的选择"><a href="#研发模式的选择" class="headerlink" title="研发模式的选择"></a>研发模式的选择</h2><ul><li>根据开发团队规模：小规模团队采用分支研发，共建型大团队采用 gitflow，更加庞大的团队采用主干开发模式。因为微服务设计的流行，现在应用的团队规模越来越小，所以在阿里分支研发模式会更受欢迎。</li><li>当某个分支功能不想发布了，分支模式可以直接退出集成，需要发布的分支重新合并 release 即可。而主干开发往往采用特性开关方式 off 掉相应功能，因为代码剥离比较困难。</li></ul><blockquote><p><strong>特性开关的理解</strong></p><ul><li>特性开关和特性分支都是解决代码并行开发的方法，帮助团队进行独立的变更发布。特性分支很容易入手，但是会引入痛苦的合并冲突。这种风险往往不利于对代码进行渐进式的优化，导致技术债务的累积并走向不归路。</li><li>特性开关允许团队实施真正的持续集成，并将代码更改与功能发布解耦，代价是增加了代码中开关的复杂性。特性开关不是万能的，也并非总是最佳选择，好在尝试使用这种方法对于开发团队来说成本很低，只需硬编码 if/else 语句即可，接下来的事情，就是检验是否可行。</li></ul></blockquote><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><h3 id="线下环境"><a href="#线下环境" class="headerlink" title="线下环境"></a>线下环境</h3><ul><li>开发测试环境：这个环境主要是开发使用，能够快速验证自己开发完的代码。不需要和线上环境相同，如果有依赖，可以直接使用集成测试环境的服务。</li><li>集成测试环境： 这个环境的应用的各类基础服务和线上环境保持一致，只是比线上环境规模小很多。因为开发和测试都在使用，同时不能影响测试的效率，所以这个环境要求稳定。如果变更是有损的，需要严格的审核，不能随意发布新的变更。如果变更是无损的，变更审核会简单点，可以较频繁的进行变更。所以无损变更可以更加充分的利用该环境，提高环境的使用效率。</li></ul><h3 id="线上环境"><a href="#线上环境" class="headerlink" title="线上环境"></a>线上环境</h3><ul><li>预发环境 ：和正式生产环境的状态基础服务共用，如 DB，KV，文件存储以及搜索类的数据服务。网络上独立网段划分，不承担线上真是流量。<blockquote><p>预发环境正式使用后的另一用途：就是生产环境出现问题，但是线下环境复现不了时，就可以在预发环境上复现。</p></blockquote></li><li>Beta环境：也叫灰度环境，金丝雀发布就是基于该环境发布。简单理解就是从生产环境的集群中，再建立一个独立集群，就是再建立一个分组，独立出一个集群，大概只有1——2台服务器数量，主要针对小规模真是业务流量。如何保证流量小规模，就需要负载均衡策略上做工作, 主要两种方式：1.调用RPC，在服务化框架的复杂均衡策略中，将其权重或者流量配比降低。2.调用HTTP，在四层VIP或者七层权重上，将其权重降低。<blockquote><p>除了承担流量不同，其他和生产环境的应用没有差别，主要针对核心应用。</p></blockquote></li><li>生产环境</li></ul><h2 id="持续交付可能面临的挑战"><a href="#持续交付可能面临的挑战" class="headerlink" title="持续交付可能面临的挑战"></a>持续交付可能面临的挑战</h2><ul><li>缺少测试覆盖的持续交付会成为负担。当我们单元测试、API测试做的不好的时候，通过流程强加的持续交付基本上是自欺欺人，要么就是不稳定，要么就是没效果。</li><li>测试团队转型，开发全栈导致的质量下降。有这么多需求，没时间写测试，或者保姆式服务享受惯了，开发人员自己没这个意识。</li></ul><h2 id="压力测试系统"><a href="#压力测试系统" class="headerlink" title="压力测试系统"></a>压力测试系统</h2><h3 id="压测粒度"><a href="#压测粒度" class="headerlink" title="压测粒度"></a>压测粒度</h3><ul><li>单机单应用压力测试</li><li>单链路压力测试</li><li>多链路/全链路压力测试<blockquote><p>多链路本质上就是多个单链路的组合，全链路就是多链路的组合。</p></blockquote></li></ul><h3 id="压测接口及流量构造方式"><a href="#压测接口及流量构造方式" class="headerlink" title="压测接口及流量构造方式"></a>压测接口及流量构造方式</h3><ol><li>接口一般分为HTTP接口和RPC接口</li><li>流量构造方式：</li></ol><ul><li>线上流量回放：<blockquote><p>直接利用了线上流量模型，比较接近真实业务场景，常见的技术手段如 TCPCopy，或者 Tcpdump 抓包保存线上请求流量。但是这种方式也存在一些代价，比如需要镜像请求流量，当线上流量非常大的时候就很难全部镜像下来，而且还需要大量额外的机器来保存流量镜像。到了回放阶段，还需要一些自动化的工具来支持，还要解决各种 session 问题，真正实施的时候，还是会有不少的工作量。</p></blockquote></li><li>线上流量引流：<blockquote><p>既然线上回放比较麻烦，那为什么不直接使用线上流量进行压测呢？这个思路确实是可行的，我们前面讲过，压测的主要是 HTTP 和 RPC 两种类型的接口，为了保证单个应用的流量压力足够大，这里可以采取两种模式。<br>一个是将应用集群中的流量逐步引流到一台主机上，直到达到其容量阈值；另一个方案是，可以通过修改负载均衡中某台主机的权重，将更多的流量直接打到某台主机上，直到达到其容量阈值。这个过程中，我们可以设定单台主机的 CPU、Load 或者 QPS、RT 等阈值指标，当指标超出正常阈值后就自动终止压测，这样就可以获取到初步的容量值。<br>这种方式的好处是，不需要额外的流量模拟，直接使用最真实的线上流量，操作方便，且更加真实。</p></blockquote></li><li>流量模拟<blockquote><p>上述两种流量模拟方式，更适合日常单机单应用的容量压测和规划，但是对于大促这种极端业务场景，真实流量就很难模拟了，因为这种场景只有特定时刻才会有，我们在日常是无法通过线上流量构造出来的。<br>所以这里就需要利用数据工厂，最终通过流量平台来形成压测流量。这里的工具用到了 Gatling，是一款开源的压测工具，用 Scala 开发的，可以针对自己的需求，比如自动生成压测脚本等，做了一些二次开发。</p></blockquote></li></ul><h3 id="施压方式"><a href="#施压方式" class="headerlink" title="施压方式"></a>施压方式</h3><p>接下来要做的就是对真实的线上系统施加压力流量了。很自然的，这里就需要有施加压力的机器。关于施压机器的分布，大部分仍然是跟线上系统在同机房内，少量会在公有云节点上。但是对于阿里，因为其自身的 CDN 节点遍布全球，所以他就可以将全球（主要是国内）的 CDN 节点作为施压机，更加真实地模拟真实用户从全球节点进入的真实访问流量。这种方式对于中小型公司就显得成本过高，技术条件和细节也还达不到这个程度。不过当前阿里已经将这种压测能力输出到了阿里云之上。</p><h3 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h3><p>压测过程中，对于读的流量更好构造，因为读请求本身不会对线上数据造成任何变更，但是对于写流量就完全不一样了，如果处理不好，会对线上数据造成污染，对商家和用户造成资损。</p><p>所以，对于写流量就要特殊处理，这块也有比较通用的解决方案，就是对压测的写请求做专门的标记。当请求要写数据库时，由分布式数据库的中间件框架中的逻辑来判断这个请求是否是压测请求，如果是压测写请求则路由到对应的影子库中，而不是直接写到线上正式的库中。</p><p>在这之前，要提前创建好对应的影子库。假设建立影子库的原则是原 schema + mirror，如果正式库是 order，则影子库为 order_mirror，这时两个库中的数据量必须是一致的。对于非敏感信息，数据内容也可以保持一致，这样可以在最大程度上保证数据模型一致。</p><hr><p>这里要重点强调一下<strong>基础服务标准化</strong>工作，如果这个工作在开始做得扎实，它的优势在这里就体现出来了。我们刚刚提到的影子库的路由策略是基于中间件框架来实现的，如果使用的框架不一样，不是标准的，这个功能可能就很难应用起来。</p>]]></content>
      
      
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>gitignore 文件配置</title>
      <link href="/2018/06/16/gitignore/"/>
      <url>/2018/06/16/gitignore/</url>
      <content type="html"><![CDATA[<h2 id="定义-gitignore-的配置文件"><a href="#定义-gitignore-的配置文件" class="headerlink" title="定义 gitignore 的配置文件"></a>定义 gitignore 的配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.gitignore</span><br><span class="line"></span><br><span class="line">$GIT_DIR/info/exclude</span><br><span class="line"></span><br><span class="line">$HOME/.config/git/ignore</span><br></pre></td></tr></table></figure><p>gitignore 用于配置Git仓库中不需要加入版本管理的文件。如果文件已经被Git追踪则不受gitignore影响。</p><h2 id="gitignore-语法规则"><a href="#gitignore-语法规则" class="headerlink" title="gitignore 语法规则"></a>gitignore 语法规则</h2><ul><li>空行不匹配任何文件，所以可以用空行来增强gitignore规则的可读性</li><li>注释行以#开头。可以在#前加一个反斜杠转义之，使之能够匹配包含”#”字符的文件夹或文件</li><li>如果每一行最后尾随的空格没有用反斜杠转义，那么这些空格是无效的，不会作为规则的一部分</li><li>使用!前缀来否定之前的规则。如果一个文件被前面的gitignore规则给匹配到了，那么该文件不会被Git追踪，但是如果后面的规则使用!匹配到了该文件，那么该文件又会被Git追踪。当然，如果一个文件的父目录都被Git忽略了，那么无论如何，这个文件都不会被Git追踪。出于性能考虑，Git不会遍历被忽略的目录，因此，定义在被忽略目录下的gitignore规则都是无效的。有时候，我们真的是想忽略以感叹号!开头的一个文件或者目录，这时，可以在感叹号!前面加一个反斜杠转义之，比如：!important.txt会匹配文件!important.txt</li><li>如果一个规则以斜杠结尾，在实际匹配的时候，最后的斜杠会被移除掉，但是这个规则只会匹配目录，而不会匹配文件。换句话说，foo/会匹配到目录foo和foo下的子目录，但不会匹配到文件foo或者软链接foo</li><li>如果规则中不包含斜杠/，Git就会就会把该规则当成通配符规则来进行处理，从该规则所在.gitignore文件所在路径开始匹配。(如果这个规则不是放在.gitignore文件中的，就会从work tree的顶部开始匹配)</li><li>如果规则不符合以上的情况，那么Git就会把这个规则当成shell glob 模式匹配。所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc]匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。</li><li>以斜杠开头的通配符规则从路径开头开始匹配。比如，/*.c匹配cat-file.c，但不匹配mozilla-sha1/sha1.c</li></ul><p>两个连续的星号**在匹配全路径名的时候可能有特殊含义：</p><ul><li>规则以两个星号<strong>开头，后接一个斜杠，这样的规则会在所有路径或子路径中尝试进行匹配。比如，</strong>/foo会匹配到文件foo或者目录foo，无论它在哪个目录；foo这条规则同样会尝试匹配所有路径中的文件foo或者目录foo。**/foo/bar规则会匹配任意文件或目录foo下直接跟的文件bar或目录bar</li><li>如果规则中间有连续的两个星号<strong>，那这条规则会匹配下面的所有东西。比如abc/</strong>会匹配目录abc下的所有文件或目录，当然，这里的目录abc是相对于.gitignore文件位置而言的，无限递归</li><li>如果规则是斜杠/后跟两个星号，然后再跟一个斜杠的形式，这里的两个星号就会匹配0+个目录，这里的0+是指可以没有，也可以是多个。再举个例子，比如a/**/b会匹配a/b、a/x/b、a/x/y/b这些</li><li>其他形式的连续星号都认为是无效的。</li></ul><h2 id="各种语言的-gitignore-配置文件模板"><a href="#各种语言的-gitignore-配置文件模板" class="headerlink" title="各种语言的 gitignore 配置文件模板"></a>各种语言的 gitignore 配置文件模板</h2><p><a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p>]]></content>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 打包学习</title>
      <link href="/2018/04/22/python-setup/"/>
      <url>/2018/04/22/python-setup/</url>
      <content type="html"><![CDATA[<p>Python的软件包一开始是没有官方的标准分发格式的。 后来不同的工具都开始引入一些比较通用的归档格式。比如，setuptools引入了Egg格式。 但是，这些都不是官方支持的，存在元数据和包结构彼此不兼容的问题。因此，为了解决这个问题， PEP 427定义了新的分发包标准，名为Wheel。目前pip和setuptools工具都支持Wheel格式。</p><h1 id="两种打包方式"><a href="#两种打包方式" class="headerlink" title="两种打包方式"></a>两种打包方式</h1><h2 id="纯setuptools打包"><a href="#纯setuptools打包" class="headerlink" title="纯setuptools打包"></a><a href="https://setuptools.readthedocs.io/en/latest/setuptools.html">纯setuptools打包</a></h2><ul><li>setuptools 是Python distutils增强版的集合，它可以帮助我们更简单的创建和分发Python包，特别是对其他包有依赖关系时。</li></ul><h3 id="使用setuptools最小的setup-py配置："><a href="#使用setuptools最小的setup-py配置：" class="headerlink" title="使用setuptools最小的setup.py配置："></a>使用setuptools最小的setup.py配置：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line">setup(</span><br><span class="line">    name=<span class="string">"HelloWorld"</span>,</span><br><span class="line">    version=<span class="string">"0.1"</span>,</span><br><span class="line">    packages=find_packages(),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>setuptools 通过find_packages函数来自动包含所有的packages，对于大型软件来说，极大的方便了packages的管理。</p><h3 id="setup-py的setup函数的常用参数："><a href="#setup-py的setup函数的常用参数：" class="headerlink" title="setup.py的setup函数的常用参数："></a>setup.py的setup函数的常用参数：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name -&gt; 为项目名称，和顶层目录名称一致;</span><br><span class="line">version -&gt; 是项目当前的版本，1.0.0.dev1表示1.0.0版，目前还处于开发阶段</span><br><span class="line">description -&gt; 是包的简单描述，这个包是做什么的</span><br><span class="line">long_description -&gt; 这是项目的详细描述，出现在pypi软件的首页上</span><br><span class="line">url -&gt; 为项目访问地址，我的项目放在github上。</span><br><span class="line">author -&gt; 为项目开发人员名称</span><br><span class="line">author_email -&gt; 为项目开发人员联系邮件</span><br><span class="line">license -&gt; 为本项目遵循的授权许可</span><br><span class="line">classifiers -&gt; 有很多设置，具体内容可以参考官方文档</span><br><span class="line">keywords -&gt; 是本项目的关键词，理解为标签</span><br><span class="line">packages -&gt; 是本项目包含哪些包，使用工具函数自动发现包</span><br><span class="line">package_data -&gt; 通常包含与包实现相关的文件</span><br><span class="line">data_files -&gt; 指定其他的一些文件（如配置文件）</span><br><span class="line">install_requires -&gt; 指定了在安装这个包的过程中, 需要哪些其他包。 如果条件不满足, 则会自动安装依赖的库。</span><br><span class="line">entry_points -&gt; 可以定义安装该模块后执行的脚本，比如将某个函数作为</span><br></pre></td></tr></table></figure><h3 id="常用的setuptools打包命令有："><a href="#常用的setuptools打包命令有：" class="headerlink" title="常用的setuptools打包命令有："></a>常用的setuptools打包命令有：</h3><ul><li>源码打包(tar.gz):</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py sdist</span><br></pre></td></tr></table></figure><ul><li>通用egg格式:<blockquote><p>本质上是一个压缩文件，只是扩展名换了，里面也包含了项目元数据以及源代码，由setuptools项目引入</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py bdist_egg</span><br></pre></td></tr></table></figure><ul><li>通用whell格式:<blockquote><p>本质上是一个压缩文件，只是扩展名换了，里面也包含了项目元数据和代码，由PEP 427引入</p></blockquote></li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py bdist_wheel</span><br></pre></td></tr></table></figure><ul><li>rpm格式打包：</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py bdist_rpm</span><br></pre></td></tr></table></figure><ul><li>应用安装</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><ul><li>以开发方式安装</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure><blockquote><p>使用”develop”开发方式安装的话，应用代码不会真的被拷贝到本地Python环境的”site-packages”目录下，而是在”site-packages”目录里创建一个指向当前应用位置的链接。这样如果当前位置的源码被改动，就会马上反映到”site-packages”里。</p></blockquote><h2 id="使用-pbr-打包"><a href="#使用-pbr-打包" class="headerlink" title="使用 pbr 打包"></a><a href="https://docs.openstack.org/pbr/latest/index.html">使用 pbr 打包</a></h2><p>OpenStack也是使用setuptools工具来进行打包，不过它引入了一个辅助工具pbr来配合setuptools完成打包工作。</p><p>那么OpenStack社区为啥要开发pbr呢？因为setuptools库使用起来还是有点麻烦，参数太多，而且直接通过指定setup函数的参数的方法实在太不方便了。pbr就是为了方便而生的，它带了了如下的改进：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用setup.cfg文件来提供包的元数据。这个是从disutils2学来的。</span><br><span class="line">基于requirements.txt文件来实现自动依赖安装。requirements.txt文件中包含了一个项目所要依赖的库。</span><br><span class="line">利用Sphinx实现文档自动化。</span><br><span class="line">基于git history自动生成AUTHORS和ChangeLog文件。</span><br><span class="line">针对git自动创建文件列表。</span><br><span class="line">基于git tags的版本号管理。</span><br></pre></td></tr></table></figure><h3 id="pbr打包配置"><a href="#pbr打包配置" class="headerlink" title="pbr打包配置"></a>pbr打包配置</h3><p>setup.py</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line">setuptools.setup(setup_requires=[<span class="string">'pbr'</span>],pbr=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>setup.cfg</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[metadata]</span><br><span class="line">name = mypackage</span><br><span class="line">description = A short description</span><br><span class="line">description-file = README.rst</span><br><span class="line">author = John Doe</span><br><span class="line">author-email = john.doe@example.com</span><br><span class="line">license = BSD</span><br></pre></td></tr></table></figure><h3 id="pbr-打包版本号（version）"><a href="#pbr-打包版本号（version）" class="headerlink" title="pbr 打包版本号（version）"></a>pbr 打包版本号（version）</h3><p>使用pbr版本号有两种方式：postversioning和preversioning，postversioning是默认方式。要是用preversioning的方式，则需要设置setup.cfg文件中的[metadata]段的version字段的值。无论采用哪种方式，版本号都是从git的历史推理得到的。pbr使用的版本号标准是Linux/Python Compatible Semantic Versioning 3.0.0，简单的说就是下面这个标准：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Given a version number MAJOR.MINOR.PATCH, increment the:</span><br><span class="line"></span><br><span class="line">MAJOR version when you make incompatible API changes,</span><br><span class="line">MINOR version when you add functionality in a backwards-compatible manner</span><br><span class="line">PATCH version when you make backwards-compatible bug fixes.</span><br></pre></td></tr></table></figure><p>pbr的版本推导按照如下的步骤进行（注意，最终版本号才是软件包的版本号）：</p><ol><li>如果设置version的值为一个给定的版本号，且这个版本号刚好对应一个tag，则这个值就是最终版本号（注意，这里只有签名的tag才有效）。</li><li>如果不是上面情况，则pbr会找到最近的一个tag，然后为其MINOR值加1得到一个比它大的最小版本号（注意，这个还不是最终版本号）。</li><li>然后pbr会从最近的一个tag (如果没有tag，默认是0.0.1) 开始遍历所有的git commit，并检查每个提交的commit message，在commit message中查找Sem-Ver:这样的行：</li></ol><p>Sem-Ver的值有如下几种：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feature</span><br><span class="line">api-break</span><br><span class="line">deprecation</span><br><span class="line">bugfix</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果Sem-Ver的值是bugfix，则会增加版本号中PATCH部分的值。</span><br><span class="line">如果Sem-Ver的值是feature或者deprecation，则会增加版本号中MINOR部分的值。</span><br><span class="line">如果Sem-Ver的值是api-break，则会增加版本号中MAJOR部分的值。</span><br><span class="line">如果Sem-Ver行不存在，则认为值是bugfix。</span><br><span class="line">如果Sem-Ver的值不在上面列出的范围内，则会给出警告。</span><br></pre></td></tr></table></figure><ul><li>如果使用的是postversioning的方式，也就是setup.cfg中不指定version的值，则pbr会使用规则3推导出来的值作为目标版本号（只是目标版本号，不是最终版本号）。</li><li>如果使用的是preversioning的方式，也就是setup.cfg中指定了version的值（而且不符合规则1），则会检查指定的version是否高于规则3推导出来的版本号，如果没有，则会抛出异常，如果有，则使用指定的版本号作为目标版本号。</li><li>在得到目标版本号之后，开始计算开发版本号。开发版本号的形式如下：MAJOR.MINOR.PATCH.devN。这里要计算的是devN中的N。这个值等于从最近的git tag开始的提交数量。计算完开发版本号之后，就得到了最终版本号。</li></ul><p>总的来说，从上面的规则计算出来的版本号只有两种形式，一种是发布版本号（对应到某个tag），另一种是开发版本号。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>pbr要求tag都是要<strong>签名</strong>的，也就是打tag时要使用git tag -a -s X.Y.Z的形式。</p><p>pbr 支持两种tag形式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 . bare version tag (e.g. 0.1.0)</span><br><span class="line">2 . 带有前缀 v 或者 V (e.g. v0.1.0))</span><br></pre></td></tr></table></figure><h3 id="创建tag如何使用GPG签名"><a href="#创建tag如何使用GPG签名" class="headerlink" title="创建tag如何使用GPG签名"></a>创建tag如何使用GPG签名</h3><p>1 . 安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Mac 环境下:</span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install gpg</span></span><br><span class="line">Centos 环境下:</span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install gnupg</span></span><br></pre></td></tr></table></figure><p>2 . 生成密钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --gen-key</span><br></pre></td></tr></table></figure><p>3 . 查看系统中已有的密钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --list-keys</span><br></pre></td></tr></table></figure><p>4 . 输出密钥</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpg --armor --export  [用户ID uid]</span><br></pre></td></tr></table></figure><p>在输出的内容中，从“—–BEGIN PGP PUBLIC KEY BLOCK—–”复制到“—–END PGP PUBLIC KEY BLOCK—–”。打开 GitHub 设置密钥的网页，粘贴 GPG 密钥.</p><p>5 . 使用签名</p><p>首先你需要为Git 设置一个用于签名的私钥，通常来说所有的个人项目都用一个私钥进行签名，所以建议设置为全局配置。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.signingkey &lt;key ID&gt;</span><br></pre></td></tr></table></figure><p>然后就可以使用这个私钥来签名提交。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -S</span><br></pre></td></tr></table></figure><p>或者签名标签了。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag -s &lt;tag&gt;</span><br></pre></td></tr></table></figure><p>如果你想全局默认使用GPG 签名提交，可以全局将commit.gpgsign 设置为true。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global commit.gpgsign true</span><br></pre></td></tr></table></figure><blockquote><p>参考文档：</p><ul><li><a href="https://segmentfault.com/a/1190000002940724">https://segmentfault.com/a/1190000002940724</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html">http://www.ruanyifeng.com/blog/2013/07/gpg.html</a></li></ul></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>持续交付：发布可靠软件的系统方法—-读书笔记</title>
      <link href="/2018/02/04/continuous-delivery-notes/"/>
      <url>/2018/02/04/continuous-delivery-notes/</url>
      <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/6862062/">豆瓣链接</a></p><p>本文主要是对阅读书籍我认为重要的内容进行概要记录。</p><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="第1章-软件交付的问题"><a href="#第1章-软件交付的问题" class="headerlink" title="第1章 软件交付的问题"></a>第1章 软件交付的问题</h2><p>1.6 软件交付原则</p><ul><li><p>为软件发布创建一个可重复且可靠的过程</p><p>如何做到：（1）几乎将所有事情自动化。（2）将构建、部署、测试和发布软件所需的东西全部纳入到版本控制管理之中。</p></li><li>将几乎所有事情自动化</li></ul><p>自动化是部署流水线的前提。</p><ul><li>把所有的东西都纳入版本控制</li></ul><p>包括文档，测试脚本，配置脚本，部署脚本，升级和回退脚本等等。</p><ul><li><p>提前并频繁地做让你感到痛苦的事</p></li><li><p>内建质量<br>将软件问题提前暴露，一旦发现流水线有失败，就要马上着手修复。</p></li><li><p>“DONE” 意味着 “已发布”</p></li></ul><p>一个特性只有交到用户手中才能算 ”DONE”。</p><blockquote><p>phylee注： 这个原则意味着，1.从开发业务代码到上线生产环境必须要快。否则一个月甚至更长时间才能上线生产环境，开发人员早就忘了。2. 业务开发人员一定会关注代码发布过程，这样也可以不断完善改进流水线，催熟流水线。</p></blockquote><ul><li>交付过程是每个成员的责任</li><li>持续改进</li></ul><h2 id="第2章-配置管理"><a href="#第2章-配置管理" class="headerlink" title="第2章 配置管理"></a>第2章 配置管理</h2><p>2.1 本章将讨论三个问题：</p><ul><li>为管理应用程序的构建，部署，测试和发布过程做好准备。从两个方面解决这个问题：对所有内容进行版本控制；管理依赖关系。</li><li>管理应用软件的配置信息。</li><li>整个环境的配置管理，包括应用程序的依赖软件，硬件和基础设施。</li></ul><p>2.2 使用版本控制</p><ul><li>对所有内容进行版本控制，不仅仅是源代码，包括测试代码，数据库脚本、构建和部署脚本等所有和软件发布的文件都要纳入版本控制中。</li><li>频繁提交代码到主干，因为长时间不提交代码会让合并工作变得过于复杂。</li></ul><p>2.4 软件配置管理</p><ul><li>应该以对待代码的方式来对待系统的配置，使其受到正确的管理和测试。</li><li>配置与灵活性。灵活性是有代价的。<blockquote><p>phylee注： 修改配置并不比修改代码风险低，因为配置修改更难被测试。除非有很好的回滚机制，因为回滚配置可以很快。回滚机制的前提是有版本控制。</p></blockquote></li></ul><p>2.5 环境管理</p><p>环境管理的关键在于能通过一个全自动过程来创建环境。</p><h2 id="第3章-持续集成"><a href="#第3章-持续集成" class="headerlink" title="第3章 持续集成"></a>第3章 持续集成</h2><p>3.2 实现持续集成 需要满足3个条件：</p><ul><li>版本控制</li><li>自动化构建</li><li>团队共识<br>团队共识很重要。持续集成不是一种工具，而是一种实践。需要开发团队的给予一定投入并遵守一些准则。</li></ul><h1 id="部署流水线"><a href="#部署流水线" class="headerlink" title="部署流水线"></a>部署流水线</h1><h2 id="第5章-部署流水线解析"><a href="#第5章-部署流水线解析" class="headerlink" title="第5章  部署流水线解析"></a>第5章  部署流水线解析</h2><p>5.3  部署流水线解析</p><ul><li>只生成一次二进制包<br>保证所有环境验证发布包是同一个。</li><li>对不同环境采用同一部署方式<br>代码和应用配置文件分离，应用配置文件和环境相关。生产环境和开发测试环境应该由同一个团队管理。</li><li>对部署进行冒烟测试</li><li>向生产环境的副本中部署<br>开发测试环境尽可能和生产环境相同。</li><li>每次变更都要立即在流水线中传递</li><li>只要有环节失败，就停止整个流水线<br>一旦出现失败，变更团队应停下手头工作，立即着手修复。</li></ul><p>5.7.2 变更的撤销<br>软件版本的快速迭代，不可避免会有一些缺陷，快速回滚是保障快速发布的的重要能力。</p><p>5.8 实现一个部署流水线<br>无论是从零创建新项目，还是想为已有的系统创建一个自动化的流水线，通常都应该使用<strong>增量方法</strong>来实现部署流水线。</p><blockquote><p>phylee注：理解“增量”很重要，流水线的建设从来不是一步到位的，不同公司交付模式不同，流水线也会不太一样，需要使用者和建设者的协作并根据实际交付流程不断完善它。</p></blockquote><p>建立完整流水线一般步骤:</p><p>1 . 对价值流进行建模并创建简单的可工作框架</p><blockquote><p>能画出从代码提交到发布的整个过程的价值流程图。</p></blockquote><p>2 . 将构建和部署流程自动化</p><p>3 . 将单元测试和代码分析自动化</p><p>4 . 将验收测试自动化</p><p>5 . 将发布自动化</p><p>5.9 度量</p><p>反馈是所有软件交付流程的核心。改善反馈的最佳方法是缩短反馈周期，并让结果可视化。</p><p>重要的问题是：度量是什么？选择什么样的度量项对团队行为有很大的影响。</p><p>对于软件交付过程来说，最重要的全局度量指标就是周期时间，它指的是从决定要做某个特性开始，直到把这个特性交付给用户的这段时间。“你所在的组织中，如果仅仅修改过一行代码，需要多长时间才能把它部h署到生产环境中？你们是否以一种可重复且可靠的方式做这类事情？”</p><h2 id="第6章-构建于部署的脚本化"><a href="#第6章-构建于部署的脚本化" class="headerlink" title="第6章 构建于部署的脚本化"></a>第6章 构建于部署的脚本化</h2><p>6.3 构建部署脚本化的原则与实践</p><ul><li>为部署流水线的每个阶段创建脚本</li><li>使用同样的脚本向所有环境部署</li><li>确保部署流程是幂等的</li></ul><p>6.5 部署脚本化</p><p>环境管理的核心原则之一就是：对测试生产环境的修改只能由自动化过程执行。也就是说，我们不应该手工远程登陆到这些环境上执行部署工作，而应该将其完全脚本化。</p><h2 id="第7章-提交阶段"><a href="#第7章-提交阶段" class="headerlink" title="第7章 提交阶段"></a>第7章 提交阶段</h2><p>编译，单元测试，编译打包，静态检查</p><p>7.2 提交阶段的原则和实践</p><ul><li>提供快速有用的反馈</li><li>让开发人员也拥有所有权</li><li>在超大项目团队中指定一个构建负责人<blockquote><p>构建负责人不应该是由固定的人担任。团队成员应该轮流担当。</p></blockquote></li></ul><p>7.3 提交阶段的结果<br>提交阶段既有输入，也有输出。输入是源代码，输出是二进制包和报告。</p><ul><li>制品库<blockquote><p>最容易想到的地方就是版本控制库，但它却不是一个正确的选择，因为这回让你的磁盘空间很快被吃掉，而且有些版本控制系统对二进制文件支持不佳。</p></blockquote></li></ul><p>制品库是一个不同寻常的版本控制系统，它仅保存某些版本，而不是全部。能够追溯已发布的软件究竟是版本控制库的哪个版本产生的。二进制文件的创建过程是可重复的。</p><p>7.4 提交测试套件的原则与实践</p><ul><li>绝大部分测试由单元测试组成。</li><li>避免用户界面测试</li><li>使用依赖注入</li><li>避免使用数据库</li><li>在单元测试中避免异步</li><li>使用测试替身<blockquote><p>打桩是指利用模拟代码来代替原系统中的某个部分，并提供已封装好的响应。</p></blockquote></li><li>最小化测试中的状态<blockquote><p>很容易落入一个陷阱，即为了支撑测试，精心地建立起一堆难以理解和维护的数据结构。理想的测试应该能很容易和快速地进行测试准备，而清理工作也应该更快、更容易。对于结构良好的代码来说，其测试代码往往也非常整洁有序。如果测试看起来繁琐复杂，那可能是系统设计有问题。当然这是一个很难定性的问题。</p></blockquote></li></ul><h2 id="第8章-自动化验收测试"><a href="#第8章-自动化验收测试" class="headerlink" title="第8章 自动化验收测试"></a>第8章 自动化验收测试</h2><p>对于一个单独的验收测试，它的目的是验证一个用户故事或需求的验收条件是否被满足。验收条件有多种类型，如功能性验收条件和非功能性验收条件。非功能性验收条件包括容量，性能，可用性，安全性，易用性等等。</p><p>与单元测试的区别：</p><p>验收测试是针对业务的，单元测试是针对开发的。验收测试的目标是要证明应用程序的确实现了客户想要的，而不是开发人员所认为的正确方式来运行的。</p><h2 id="第10章-应用程序的部署与发布"><a href="#第10章-应用程序的部署与发布" class="headerlink" title="第10章 应用程序的部署与发布"></a>第10章 应用程序的部署与发布</h2><p>10.4 部署回滚和零停机发布</p><p>两个重要的约束。首先是数据，如果发布流程会修改数据，回滚操作就比价困难。另一个是需要与其他系统集成，如果发布中涉及两个以上的系统，回滚流程也会比较复杂。</p><p>10.4.1 通过重新部署原有的正常版本来进行回滚</p><p>10.4.2 零停机发布 (也称为热部署)</p><p>10.4.3 蓝绿部署</p><p>10.4.4 金丝雀发布</p><p>好处：</p><ul><li>非常容易回滚。只要不把用户引导这个有问题的版本就行了，此时就可以来分析日志，查找问题。</li><li>可以做A/B测试。某些公司会度量新特性额使用率，如果用的人不多，就会废弃它。（A/B测试也可以通过特性开关方式实现）</li><li>可以通过逐渐增加负载，慢慢地把更多的用户引到新版本，记录并衡量应用程序的响应时间、CPU使用率， I/O、内存使用率以及日志中是否有异常报告这种方式，来检查一下应用程序是否满足容量需求。</li></ul><p>10.7 小贴士和窍门</p><ul><li>真正执行部署操作的人应该参与部署过程的创建</li><li>记录部署活动</li><li>不要删除旧文件，而是移动到别的位置</li><li>部署是整个团队的责任<blockquote><p>团队每个成员都应该知道如何部署，如何维护部署脚本。</p></blockquote></li><li>不要直接对生产环境进行修改<blockquote><p>生产环境应该是完全锁定的，这样只有部署流水线可以对其进行改变，包括从环境配置信息到部署在其中的应用程序和相关数据。</p></blockquote></li></ul><h1 id="交付生态圈"><a href="#交付生态圈" class="headerlink" title="交付生态圈"></a>交付生态圈</h1><h2 id="第12章-数据管理"><a href="#第12章-数据管理" class="headerlink" title="第12章 数据管理"></a>第12章 数据管理</h2><p>12.4.2 将应用程序部署与数据库迁移解耦</p><p>对数据库大多数修改应该是增加操作（比如向数据库中增加新表或字段），尽可能不修改已存在的结构。</p><p>12.6 数据管理和部署流水线</p><p>好的提交测试会避免复杂的数据准备。如果你发现自己很难为某个测试准备数据的话，这是一个明显的信号，表示你的设计需要更好地解耦。</p><h2 id="第13章-组建和依赖管理"><a href="#第13章-组建和依赖管理" class="headerlink" title="第13章 组建和依赖管理"></a>第13章 组建和依赖管理</h2><p>13.3 依赖</p><p>组件（component）和库（library）的差异：</p><p>库是指团队除了选择权以外，没有控制权的那些软件包，它们通常很少更新。相反，组件是指应用程序所依赖的部分软件块，但它通常是由你自己的团队或你公司的其他团队开发的。组件通常更新频繁。</p><p>13.3.1 依赖地狱</p><p>依赖管理最常见的问题可能就是所谓的“依赖地狱”（dependency hell）, 有时被称为“DLL地狱”。当一个应用程序依赖于某个库的特定版本，但实际部署的是另一个版本，或者根本没有部署时，依赖地狱就产生了。</p><p>13.6 管理二进制包</p><p>13.6.1 制品库是如何运作的</p><p>制品库的最重要特性就是，它不应该包含那些无法重现的产物。你应该能删除制品库，却不必担心无法找回有价值的内容。</p><p>为什么要删除二进制产物呢？因为这些产物很大，考虑到存储空间，你最终也需要删除他们。已通过所有测试的产物和待发布的候选版本保存下来是非常值得的。已经发布过的也值得保存，因为可能会回滚到前面的版本，或需要对旧版本的用户提供一些技术支持。</p><h2 id="第14章-版本控制进阶"><a href="#第14章-版本控制进阶" class="headerlink" title="第14章 版本控制进阶"></a>第14章 版本控制进阶</h2><p>14.6 主干开发</p><p>好处：</p><ul><li>确保所有的代码被持续集成</li><li>确保开发人员及时获得他人的修改</li><li>避免项目后期的“合并地狱”和“集成地狱”</li></ul><h2 id="第15章-持续交付管理"><a href="#第15章-持续交付管理" class="headerlink" title="第15章 持续交付管理"></a>第15章 持续交付管理</h2><p>实现持续交付不仅仅是买些工具，做一些自动化的工作。它依赖于交付过程中所涉及的每个人的协作，来自管理层的支持，以及基层人员的改进意愿。</p>]]></content>
      
      
        <tags>
            
            <tag> CICD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell学习</title>
      <link href="/2018/01/27/shell-script/"/>
      <url>/2018/01/27/shell-script/</url>
      <content type="html"><![CDATA[<p>#</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>1.定义变量,变量名和等号之间不能有空格。</p><blockquote><p>variableName=”value”</p></blockquote><p>2.使用一个定义过的变量，只要在变量名前面加美元符号（$）即可。变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $variableName</span><br><span class="line">echo $&#123;variableName&#125;</span><br></pre></td></tr></table></figure><p>3.特殊变量</p><table><thead><tr><th>变量</th><th>含义</th></tr></thead><tbody><tr><td>$0</td><td>当前脚本的文件名</td></tr><tr><td>$n</td><td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。如：1，2,…</td></tr><tr><td>$#</td><td>传递给脚本或函数的参数个数</td></tr><tr><td>$*</td><td>传递给脚本或函数的所有参数。</td></tr><tr><td>$@</td><td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同</td></tr><tr><td>$?</td><td>上个命令的退出状态，或函数的返回值。</td></tr><tr><td>$$</td><td>当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID</td></tr></tbody></table><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串可以用单引号，也可以用双引号，也可以不用引号。</p><ol><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的； 单引号字串中不能出现单引号（对单引号使用转义符后也不行）。</li><li>双引号里可以有变量 双引号里可以出现转义字符</li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo "Total value : $val"</span><br></pre></td></tr></table></figure><ol><li>表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2 。</li><li>完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ol><h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等，相等返回 true</td><td>[ a = b ] 返回 false</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不相等返回 true</td><td>[ a != b ] 返回 true</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回 true</td><td>[ -z $a ] 返回 false</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回 true</td><td>[ -z $a ] 返回 true</td></tr><tr><td>str</td><td>检测字符串是否为空，不为空返回 true</td><td>[ $a ] 返回 true</td></tr></tbody></table><blockquote><p>字符串判断相等是 ”=”，数字判断相等是 “==”</p></blockquote><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ expression ]</span><br><span class="line">then</span><br><span class="line">   Statement(s) to be executed if expression is true</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol><li>最后必须以 fi 来结尾闭合 if，fi 就是 if 倒过来拼写。</li><li>expression 和方括号([ ])之间必须有空格，否则会有语法错误。</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>在 Shell 中，用括号来表示数组，数组元素用“空格”符号分割开。定义数组的一般形式为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure><p>读取数组元素值的一般格式是：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Shell 函数的定义格式:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">function function_name () &#123;</span><br><span class="line">    list of commands</span><br><span class="line">    [ return value ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Shell 函数必须先定义后使用。</li><li>函数名前关键字 function 可加可不加。</li><li>函数返回值，可以显式增加 return 语句；如果不加，会将最后一条命令运行结果作为返回值。</li><li>Shell 函数返回值只能是整数，一般用来表示函数执行成功与否，0表示成功，其他值表示失败。如果 return 其他数据，比如一个字符串，往往会得到错误提示：“numeric argument required”。</li><li>在 Shell中，调用函数时可以向其传递参数。在函数体内部，通过 n的形式来获取参数的值，例如，1 表示第一个参数，$2 表示第二个参数…。当 n&gt;=10 时，需要使用 ${n} 来获取参数。</li></ol><h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，它的基本的形式如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure><p>将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt; EOF &gt; test.txt</span><br><span class="line">This is a simple test</span><br><span class="line">This is a simple test</span><br><span class="line">This is a simple test</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol><li>结尾的 delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li><li>开始的 delimiter 前后的空格会被忽略掉。</li><li>EOF 只是一个标识而已，可以替换成任意的合法字符。</li></ol><h2 id="echo-和-printf-的区别"><a href="#echo-和-printf-的区别" class="headerlink" title="echo 和 printf 的区别"></a>echo 和 printf 的区别</h2><ul><li>echo 命令格式</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo arg</span><br></pre></td></tr></table></figure><p>后面接字符串或者变量可以加双引号也可以不加。可以显示转义字符。</p><ul><li>printf 命令的语法：参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></table></figure><blockquote><p>注：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">format-string 为格式控制字符串，arguments 为参数列表。</span><br><span class="line">printf 命令不用加括号</span><br><span class="line">format-string 可以没有引号，但最好加上，单引号双引号均可.</span><br><span class="line">参数多于格式控制符(%)时，format-string 可以重用，可以将所有参数都转换</span><br><span class="line">arguments 使用空格分隔，不用逗号</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>printf 不像 echo 那样会自动换行，必须显式添加换行符(\n)。</li><li>printf 由 POSIX 标准所定义，移植性要比 echo 好。</li></ul><h2 id="fork-source-exec的区别"><a href="#fork-source-exec的区别" class="headerlink" title="fork, source, exec的区别"></a>fork, source, exec的区别</h2><p>fork: 当前执行的脚本程序，是在父进程 (当前shell) 产生的一个子进程 (sub-shell)中执行的, 子进程在结束后，将返回到父进程中。 在子进程的环境中如何变更，均不会影响父进程的环境。</p><p>source: 是让当前脚本在当前 shell 执行， 而不是产生一个 sub-shell 来执行。 由于所有执行结果均在当前 shell 内执行、而不是产生一个 sub-shell 来执行,  该脚本对环境产生的变更，会影响当前shell的环境。</p><p>exec:  与fork不同，不需要新开一个 sub-shell 来执行当前脚本， 而是在当前 shell 内执行（这一点和source相同）。但是使用exec 调用一个新脚本以后, 父脚本中 exec 行之后的内容就不会再执行了（这一点和source和fork都不同）。</p><h2 id="多个目录切换-pushd，-popd，-dirs"><a href="#多个目录切换-pushd，-popd，-dirs" class="headerlink" title="多个目录切换-pushd， popd， dirs"></a>多个目录切换-pushd， popd， dirs</h2><p>目录栈是用户最近访问过的系统目录列表，并以堆栈的形式管理。<br>dirs ：显示当前目录栈中的所有记录。<br>pushd： 常用于将目录加入到栈中，加入记录到目录栈顶部，并切换到该目录；若pushd命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置。<br>popd： 用于删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录。</p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 命令备忘</title>
      <link href="/2018/01/21/linux-cli/"/>
      <url>/2018/01/21/linux-cli/</url>
      <content type="html"><![CDATA[<p>本文档主要记录一些 Linux 的命令，不一定常用，只是方便个人查询。</p><h2 id="查看系统信息（系统内核名，主机名，内核版本，内核发布号等）"><a href="#查看系统信息（系统内核名，主机名，内核版本，内核发布号等）" class="headerlink" title="查看系统信息（系统内核名，主机名，内核版本，内核发布号等）"></a>查看系统信息（系统内核名，主机名，内核版本，内核发布号等）</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure><h2 id="查看硬件信息"><a href="#查看硬件信息" class="headerlink" title="查看硬件信息"></a>查看硬件信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure><blockquote><p>若命令不存在，CentOS安装方法“ yum install lshw ”</p></blockquote><h2 id="查看块设备（硬盘，闪存驱动器）信息"><a href="#查看块设备（硬盘，闪存驱动器）信息" class="headerlink" title="查看块设备（硬盘，闪存驱动器）信息"></a>查看块设备（硬盘，闪存驱动器）信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><h2 id="查看-CPU-信息"><a href="#查看-CPU-信息" class="headerlink" title="查看 CPU 信息"></a>查看 CPU 信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lscpu</span><br></pre></td></tr></table></figure><h2 id="查看文件系统信息"><a href="#查看文件系统信息" class="headerlink" title="查看文件系统信息"></a>查看文件系统信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><h2 id="查看-Linux-下最大文件描述符限制"><a href="#查看-Linux-下最大文件描述符限制" class="headerlink" title="查看 Linux 下最大文件描述符限制"></a>查看 Linux 下最大文件描述符限制</h2><ul><li>系统级限制</li></ul><p>sysctl命令和proc文件系统中查看到的数值是一样的，它是限制所有用户打开文件描述符的总和</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -a | grep -i file-max --color</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max</span><br></pre></td></tr></table></figure><ul><li>进程级限制</li></ul><p>内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理，默认值一般是1024</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -n</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ACL学习</title>
      <link href="/2018/01/20/acl/"/>
      <url>/2018/01/20/acl/</url>
      <content type="html"><![CDATA[<h2 id="ACL-简介"><a href="#ACL-简介" class="headerlink" title="ACL 简介"></a>ACL 简介</h2><p>ACL—访问控制列表（Access Control List），为Linux文件系统提供了更加灵活的权限机制。可以针对某一个用户或某一个群组来设定特定的权限需求。</p><h3 id="查看文件系统是否支持-ACL"><a href="#查看文件系统是否支持-ACL" class="headerlink" title="查看文件系统是否支持 ACL"></a>查看文件系统是否支持 ACL</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tune2fs -l /dev/vda1 | grep <span class="string">"Default mount options:"</span></span></span><br><span class="line"></span><br><span class="line">Default mount options:    user_xattr acl</span><br></pre></td></tr></table></figure><h2 id="两个命令"><a href="#两个命令" class="headerlink" title="两个命令"></a>两个命令</h2><h3 id="setfacl"><a href="#setfacl" class="headerlink" title="setfacl"></a>setfacl</h3><blockquote><p>设置文件或目录的 ACL 权限</p></blockquote><ul><li><p>为 user 设置 ACL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setfacl -m <span class="string">"u:user:permissions"</span> &lt;file/dir&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>删除 user 的 ACL 设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setfacl -x <span class="string">"u:user"</span> &lt;file/dir&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>为 group 设置 ACL</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setfacl -m <span class="string">"g:group:permissions"</span> &lt;file/dir&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>删除 group 的 ACL 设置</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setfacl -x <span class="string">"g:group"</span> &lt;file/dir&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>删除文件或目录的全部 ACL 权限</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> setfacl -b &lt;file/dir&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="getfacl"><a href="#getfacl" class="headerlink" title="getfacl"></a>getfacl</h3><blockquote><p>获取文件或目录的 ACL 权限</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> getfacl filename/dirname</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个简单的 http 服务</title>
      <link href="/2017/11/08/Python-http/"/>
      <url>/2017/11/08/Python-http/</url>
      <content type="html"><![CDATA[<p>进入要共享的目录，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果不填 port 的话，默认端口是 8000</span></span><br><span class="line"><span class="comment"># Python2.x</span></span><br><span class="line">$ python -m SimpleHTTPServer &lt;port&gt;</span><br></pre></td></tr></table></figure></p><p>1 . 在本机访问 <a href="http://localhost:8000">http://localhost:8000</a></p><p>2 . 局域网可共享, 访问 http://[共享机器ip]:8000</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://funhacks.net/2016/07/24/python_http_server/">http://funhacks.net/2016/07/24/python_http_server/</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两种 sudo 技巧</title>
      <link href="/2017/10/23/sudo/"/>
      <url>/2017/10/23/sudo/</url>
      <content type="html"><![CDATA[<h2 id="1-Vim-编辑需要root权限的文件忘记使用-sudo"><a href="#1-Vim-编辑需要root权限的文件忘记使用-sudo" class="headerlink" title="1 . Vim 编辑需要root权限的文件忘记使用 sudo:"></a>1 . Vim 编辑需要root权限的文件忘记使用 sudo:</h2><p>不需要不保存强行退出，重新加sudo再编辑。</p><p>只要在Vim的普通模式下，按 :w !sudo tee % ，这样就可以 root 权限来保存文件。</p><h2 id="2-执行-需要root-权限命令忘记加-sudo"><a href="#2-执行-需要root-权限命令忘记加-sudo" class="headerlink" title="2 . 执行 需要root 权限命令忘记加 sudo:"></a>2 . 执行 需要root 权限命令忘记加 sudo:</h2><p>不需要重新输入。</p><p>只要输入 sudo !! 即可，这里的 !! 代表上一条命令。</p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VirtualBox命令行</title>
      <link href="/2017/10/23/change-virtualbox/"/>
      <url>/2017/10/23/change-virtualbox/</url>
      <content type="html"><![CDATA[<h2 id="1-如果修改虚拟机的配置，需要先关闭虚拟机"><a href="#1-如果修改虚拟机的配置，需要先关闭虚拟机" class="headerlink" title="1 . 如果修改虚拟机的配置，需要先关闭虚拟机"></a>1 . 如果修改虚拟机的配置，需要先关闭虚拟机</h2><h2 id="2-使用VBoxManage命令行查看虚拟机信息也可以修改配置"><a href="#2-使用VBoxManage命令行查看虚拟机信息也可以修改配置" class="headerlink" title="2 . 使用VBoxManage命令行查看虚拟机信息也可以修改配置"></a>2 . 使用VBoxManage命令行查看虚拟机信息也可以修改配置</h2><p>VBoxManage [-v|-version]  显示virtualbox的版本号</p><p>VBoxManage list vms|runningvms  显示列表虚拟机|正在运行的虚拟机</p><p>VBoxManage showvminfo | 显示指定虚拟机的信息</p><blockquote><p>[-details] 显示详细信息</p></blockquote><blockquote><p>[-statistics] 显示统计信息</p></blockquote><blockquote><p>[-machinereadable] 以清晰的格式显示虚拟机信息</p></blockquote><p>VBoxManage registervm 将指定文件所在的虚拟机添加到列表</p><p>VBoxManage unregistervm | 从虚拟机列表清除指定的虚拟机</p><blockquote><p>[-delete] 从虚拟机列表删除指定的虚拟机</p></blockquote><p>VBoxManage createvm -name 创建指定名称的虚拟机</p><blockquote><p>[-register] 将创建的虚拟机添加到列表</p></blockquote><blockquote><p>[-basefolder 指定虚拟机的基础目录</p></blockquote><blockquote><p>[-settingsfile ] 指定虚拟机配置文件的基础目录</p></blockquote><blockquote><p>[-uuid ] 创建指定uuid的虚拟机</p></blockquote><p>VBoxManage modifyvm 编辑指定的虚拟机的配置</p><blockquote><p>[-name ] 修改虚拟机的名称<br>[-ostype ]修改虚拟机的操作系统类型<br>[-memory ] 修改虚拟机的内存大小<br>[-vram ] 修改虚拟机的显存大小</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Virtualization </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习资料归档</title>
      <link href="/2017/07/30/learning-materials/"/>
      <url>/2017/07/30/learning-materials/</url>
      <content type="html"><![CDATA[<h2 id="Linux学习资料链接"><a href="#Linux学习资料链接" class="headerlink" title="Linux学习资料链接"></a>Linux学习资料链接</h2><ul><li><a href="http://tille.garrels.be/training/tldp/">Introduction to Linux</a></li><li><a href="https://www.gitbook.com/book/lihz1990/transoflptg/details">Linux性能调优指南</a></li></ul><h2 id="Python学习资料链接"><a href="#Python学习资料链接" class="headerlink" title="Python学习资料链接"></a>Python学习资料链接</h2><ul><li><a href="https://awesome-python.com/">awesome-python</a></li><li><a href="http://pythonguidecn.readthedocs.io/zh/latest/index.html">Python最佳实践指南</a></li><li><a href="http://funhacks.net/2016/04/24/python_将字符串转为字典/">如何将字符串转为字典</a></li></ul><h2 id="shell脚本学习资料链接"><a href="#shell脚本学习资料链接" class="headerlink" title="shell脚本学习资料链接"></a>shell脚本学习资料链接</h2><ul><li><a href="https://linuxtoy.org/archives/shell-programming-execute.html">Shell 编程之执行过程</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/11/bash-set.html">Bash 脚本 set 命令教程</a></li><li><a href="http://awk.readthedocs.io/en/latest/index.html">AWK程序设计语言</a></li></ul><h2 id="数据库学习资料链接"><a href="#数据库学习资料链接" class="headerlink" title="数据库学习资料链接"></a>数据库学习资料链接</h2><ul><li><a href="http://wiki.jikexueyuan.com/project/mongodb/">Mongodb 教程</a></li></ul><h2 id="版本控制工具"><a href="#版本控制工具" class="headerlink" title="版本控制工具"></a>版本控制工具</h2><ul><li><a href="https://git-scm.com/book/zh/v2">git-scm</a></li><li><a href="http://svndoc.iusesvn.com/svnbook/1.1/index.html">使用Subversion进行版本控制</a></li><li><a href="http://www.worldhello.net/gotgithub/index.html">GotGitHub</a></li></ul><h2 id="开源监控工具"><a href="#开源监控工具" class="headerlink" title="开源监控工具"></a>开源监控工具</h2><p>1 .Supervisor</p><ul><li><a href="https://github.com/Supervisor/supervisor">源码</a></li><li><a href="https://www.rddoc.com/doc/Supervisor/3.3.1/zh/">中文文档</a></li></ul><p>2 . Monit</p><ul><li><a href="https://github.com/arnaudsj/monit">源码</a></li><li><a href="https://mmonit.com/monit/documentation/monit.html">文档</a></li></ul><h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><h3 id="Ceph"><a href="#Ceph" class="headerlink" title="Ceph"></a>Ceph</h3><ul><li><a href="http://docs.ceph.com/docs/master/architecture/">文档</a></li><li><a href="https://github.com/ceph/ceph">源码</a></li></ul><h3 id="GlusterFS"><a href="#GlusterFS" class="headerlink" title="GlusterFS"></a>GlusterFS</h3><ul><li><a href="http://docs.gluster.org/en/latest/">文档</a></li><li><a href="https://github.com/gluster/glusterfs">源码</a></li></ul><h3 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h3><ul><li><a href="https://docs.openstack.org/swift/latest/">文档</a></li><li><a href="https://github.com/openstack/swift">源码</a></li></ul><h3 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a>FastDFS</h3><ul><li><a href="https://github.com/happyfish100/fastdfs">源码</a></li><li><a href="http://blog.csdn.net/xingjiarong/article/category/6077032">分布式文件存储FastDFS</a></li><li><a href="http://bbs.chinaunix.net/forum-240-7.html">http://bbs.chinaunix.net/forum-240-7.html</a></li><li><a href="https://www.gitbook.com/book/aceld/project-d-storage">https://www.gitbook.com/book/aceld/project-d-storage</a></li></ul><h3 id="常见开源分布式存储系统对比"><a href="#常见开源分布式存储系统对比" class="headerlink" title="常见开源分布式存储系统对比"></a>常见开源分布式存储系统对比</h3><ul><li><a href="http://www.charmingzhou.com/distributed.html">http://www.charmingzhou.com/distributed.html</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Doc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>文件传输工具(Linux)</title>
      <link href="/2017/07/07/file-transfer/"/>
      <url>/2017/07/07/file-transfer/</url>
      <content type="html"><![CDATA[<h2 id="sshpass"><a href="#sshpass" class="headerlink" title="sshpass"></a>sshpass</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install sshpass</span><br></pre></td></tr></table></figure><h3 id="使用方法（3种）"><a href="#使用方法（3种）" class="headerlink" title="使用方法（3种）"></a>使用方法（3种）</h3><p>1 . 直接用密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sshpass -p 'host_pass' ssh user@host_ip 'df -h'</span><br><span class="line">sshpass -p 'host_pass' scp -r root@host_ip:/home/test/ ./tmp/</span><br></pre></td></tr></table></figure><p>首次连接需要加参数-o StrictHostKeyChecking=no, 否则return code是6 ：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sshpass -p 'host_pass' ssh  -o StrictHostKeyChecking=no  user@host_ip 'df -h'</span><br></pre></td></tr></table></figure><p>2 . 使用环境变量保存密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export SSHPASS='host_pass'</span><br><span class="line">sshpass -e ssh user@host_ip 'df -h'</span><br></pre></td></tr></table></figure><p>3 . 使用文件保存密码</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sshpass -f password_filename ssh user@host_ip 'df -h'</span><br></pre></td></tr></table></figure><h2 id="rysnc"><a href="#rysnc" class="headerlink" title="rysnc"></a>rysnc</h2><p>快速，增量的文件传输工具。支持本地和远程文件传输。</p><h3 id="注意目录后斜杠“-”"><a href="#注意目录后斜杠“-”" class="headerlink" title="注意目录后斜杠“/”"></a>注意目录后斜杠“/”</h3><p>rsync 遵循 BSD cp 的约定, 源目录后面带有一个斜杠“/”有着特定的处理。<br>比如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -r source destination</span><br></pre></td></tr></table></figure><p>创建一个有着 “source”内容的 “destination/source”目录。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -r source/ destination</span><br></pre></td></tr></table></figure><p>把”source/“目录下的所有文件全部复制到”destination”目录下，而没有中间的子目录, 就像你调用了：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rsync -r source/. destination</span><br></pre></td></tr></table></figure><p>这与 GNU cp 的行为是不同的，在GNU cp中”source” 与 “source/“ 意义相同 (不是”source/.”)。此外，一些shell可以在你键入Tab补全的时候自动自动给目录追加尾部下划线。需要注意自身的使用场景，避免这种细节上的错误。</p><h3 id="rysnc为何传输速度快？"><a href="#rysnc为何传输速度快？" class="headerlink" title="rysnc为何传输速度快？"></a>rysnc为何传输速度快？</h3><p>无论是本地或远程文件传输， rsync 首先创建每个源文件块校验的索引。此索引用于查找可能存在于目标中的任何相同数据块。一旦这种块存在，块就被就地使用，而不是从源复制。这大大加快了存在小差异的大文件的同步</p><h2 id="scp-（可搭配expect）"><a href="#scp-（可搭配expect）" class="headerlink" title="scp （可搭配expect）"></a>scp （可搭配expect）</h2><h3 id="expect是一个用来处理交互的命令"><a href="#expect是一个用来处理交互的命令" class="headerlink" title="expect是一个用来处理交互的命令"></a>expect是一个用来处理交互的命令</h3><p>expect中四个常用命令是send,expect,spawn,interact。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">send：用于向进程发送字符串</span><br><span class="line">expect：从进程接收字符串</span><br><span class="line">spawn：启动新的进程</span><br><span class="line">interact：允许用户交互</span><br></pre></td></tr></table></figure><p>Example: 如下脚本autoscp.sh</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">set user [lindex $argv 0]</span><br><span class="line">set ip [lindex $argv 1]</span><br><span class="line">set passwd [lindex $argv 2]</span><br><span class="line">set srcfile [lindex $argv 3]</span><br><span class="line">set dstdir [lindex $argv 4]</span><br><span class="line"></span><br><span class="line">set timeout 20</span><br><span class="line">spawn scp $srcfile $user@$ip:$dstdir</span><br><span class="line">expect &#123;</span><br><span class="line">"yes/no)?" &#123; send "yes\r";puts "yes" &#125;</span><br><span class="line">"assword:" &#123; send "$passwd\r" &#125;</span><br><span class="line">timeout &#123; puts "$IP time out" ;exit 1 &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>注意点：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 . /usr/bin/expect就是 which expect 的路径</span><br><span class="line">2 . 脚本需要执行权限。 chmod +x autoscp.sh</span><br><span class="line">3 . 执行脚本是./autoscp.sh, 不是 sh autoscp.sh。否则会报一些命令not found。</span><br><span class="line">    因为该脚本用的并不是bash,脚本第一行已经写明。</span><br><span class="line">4 . expect中执行命令是有一个timeout的设定的，默认超时时间为10s。</span><br><span class="line">    若一条命令未timeout限定时间内执行完，就会中断该条命令的下一条命令。</span><br><span class="line">    在expect脚本中设定timeout，可覆盖原本的timeout.</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>胡思乱想</title>
      <link href="/2017/07/04/think-and-write/"/>
      <url>/2017/07/04/think-and-write/</url>
      <content type="html"><![CDATA[<h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>用门禁和测试用例去拦截开发版本里的bug，那么又如何保证门禁和测试用例代码正确呢？再写一个拦截门禁的门禁，测试用例的测试，写到什么程度合适？</p><h2 id="自由软件"><a href="#自由软件" class="headerlink" title="自由软件"></a>自由软件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">斯托曼在GPL的序言中说：“当我们说自由软件这个词的时候，我们在说的是自由，而不是免费。”</span><br></pre></td></tr></table></figure><p>自由软件都是开源软件，但是开源软件不一定是自由软件。开源不一定免费，闭源也不一定就要收费。</p><h2 id="运维如何避免琐碎？"><a href="#运维如何避免琐碎？" class="headerlink" title="运维如何避免琐碎？"></a>运维如何避免琐碎？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基础架构的服务化平台开发，目标是平台自助化，让开发依赖平台的能力自助完成对基础组件的需求，</span><br><span class="line">而不是依赖运维的人。这个事情是驱动运维转型和改进的动力，也是运维能够深入了解架构组件细节的有效途径。</span><br><span class="line">同时，要注意到，如果不朝着服务化方向发展，运维将始终被拖累在这些基础组件的运维操作上。</span><br></pre></td></tr></table></figure><p>通过技术将人力从繁琐的工作中解放出来，否则这个团队技术很难快速成长。</p><h2 id="监控和测试"><a href="#监控和测试" class="headerlink" title="监控和测试"></a>监控和测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 机器监控</span><br><span class="line">对于机器监控有很多开源的方案，一般来说主要采集机器的CPU，内存，TPS，JVM等指标，</span><br><span class="line">一旦某个指标跨过红线，及时做出报警。</span><br><span class="line"></span><br><span class="line">* 业务监控</span><br><span class="line">对于业务数据比较复杂，根据不同的业务有几十种不同的监控指标，主要采用的是日志打点的方式。</span><br><span class="line">生产环境的每台机器会有一个专门解析日志的agent，这些agent增量的实时监控业务日志，</span><br><span class="line">并将日志解析得到跟业务相关的数据，发送给监控系统，从而监控系统能得到某个点或者</span><br><span class="line">某个时间段内的业务情况，根据划定的业务指标红线给出报警。</span><br><span class="line"></span><br><span class="line">* 功能监控</span><br><span class="line">将相关系统的冒烟用例在线上7*24小时连续不断运行，来及时发现线上的问题，</span><br><span class="line">尽量在先于用户发现问题避免故障面的扩大。</span><br><span class="line"></span><br><span class="line">* 页面监控</span><br><span class="line">对不同系统的页面7*24小时访问，看这些页面是否能够正常访问，链接是否被修改。</span><br></pre></td></tr></table></figure><p>监控是不是一种测试？测试是不是也是一种监控？</p>]]></content>
      
      
        <tags>
            
            <tag> Doc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS7免密码远程登录ssh配置</title>
      <link href="/2017/05/06/ssh-login/"/>
      <url>/2017/05/06/ssh-login/</url>
      <content type="html"><![CDATA[<h3 id="生成证书公私钥"><a href="#生成证书公私钥" class="headerlink" title="生成证书公私钥"></a>生成证书公私钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span></span><br></pre></td></tr></table></figure><p>默认在 ~/.ssh目录生成两个文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id_rsa：私钥</span><br><span class="line">id_rsa.pub：公钥</span><br></pre></td></tr></table></figure></p><h3 id="将公钥复制到远程服务器"><a href="#将公钥复制到远程服务器" class="headerlink" title="将公钥复制到远程服务器"></a>将公钥复制到远程服务器</h3><h5 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp ~/.ssh/id_rsa.pub xxx@host:/home/&#123;username&#125;/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv ~/.ssh/id_rsa.pub  ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>因为配置文件/etc/ssh/sshd_config里是.ssh/authorized_keys，所以要重命名。</p><p>注意权限设置很重要! .ssh目录权限应为700</p><h5 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-copy-id -i ~/.ssh/id_rsa.pub xxx@host</span><br></pre></td></tr></table></figure><p> ssh-copy-id命令可以把本地主机的公钥复制到远程主机的authorized_keys文件上，也会给远程主机的~/.ssh, 和~/.ssh/authorized_keys设置合适的权限。</p><h3 id="重启ssh服务"><a href="#重启ssh服务" class="headerlink" title="重启ssh服务"></a>重启ssh服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ systemctl restart sshd.service</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>修改yum源和pip源为国内镜像源</title>
      <link href="/2017/02/27/change-yum-and-pip/"/>
      <url>/2017/02/27/change-yum-and-pip/</url>
      <content type="html"><![CDATA[<h2 id="yum源修改"><a href="#yum源修改" class="headerlink" title="yum源修改"></a>yum源修改</h2><h4 id="1-备份"><a href="#1-备份" class="headerlink" title="1.备份"></a>1.备份</h4><p>首先要备份yum源，如果出现未知的错误，方便快速恢复。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><h4 id="2-下载国内镜像源"><a href="#2-下载国内镜像源" class="headerlink" title="2.下载国内镜像源"></a>2.下载国内镜像源</h4><p>以163源为例，也可以是其他国内镜像源，如阿里云等。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">$ wget http://mirrors.163.com/.<span class="built_in">help</span>/CentOS7-Base-163.repo</span><br><span class="line">$ mv CentOS7-Base-163.repo CentOS-Base.repo</span><br></pre></td></tr></table></figure><h4 id="3-生成缓存"><a href="#3-生成缓存" class="headerlink" title="3.生成缓存"></a>3.生成缓存</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ yum clean all</span><br><span class="line">$ yum makecache</span><br></pre></td></tr></table></figure><h2 id="pip源修改"><a href="#pip源修改" class="headerlink" title="pip源修改"></a>pip源修改</h2><h4 id="1-在主目录下创建-pip文件夹"><a href="#1-在主目录下创建-pip文件夹" class="headerlink" title="1.在主目录下创建.pip文件夹"></a>1.在主目录下创建.pip文件夹</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/.pip</span><br></pre></td></tr></table></figure><h4 id="2-在-pip目录下创建pip-conf文件，添加如下内容"><a href="#2-在-pip目录下创建pip-conf文件，添加如下内容" class="headerlink" title="2.在.pip目录下创建pip.conf文件，添加如下内容"></a>2.在.pip目录下创建pip.conf文件，添加如下内容</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">trusted-host =  pypi.douban.com</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><p>这里是以豆瓣pip源为例，由于最新的pip安装需要使用的https加密，所以在此需要添加trusted-host 。</p>]]></content>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
